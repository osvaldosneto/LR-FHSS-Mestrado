% Função para gerar as portadoras, distâncias, potência recebida e o
% coeficiente de desvanecimento para cada transmissão de fragmento

function [x] = Analysys(pattern, pr, pack_tx_segments, Simulation_T, Header_size, Last_fragment_duration)
    t_window = 3/2*pack_tx_segments(1,end)-pack_tx_segments(1,1);
    delta_window = t_window/2;
    Header_duration = 0.233; %233 ms long headers
    F_duration = 0.05;       %50 ms payload data fragments

    % rever este valor, funciona somente para DR8, limiar para decodificar
    % pacote
    Threshold = 4;

    t_window_start = 0;

    % removendo twait (desnecessário para análise)
    pack_tx_segments(:,Header_size+1) = [];
    pattern(:,Header_size+1) = [];
    pr(:,Header_size+1) = [];

    %% separando a janela de tempo detrerminada
    while t_window_start < Simulation_T

        %% selecionando todos os nós transmitidos dentro da janela
        [index_window_row, index_window_col] = find(pack_tx_segments>=t_window_start & pack_tx_segments<=(t_window_start+t_window));
        index_window = [index_window_row, index_window_col];
        keys = unique(index_window_row);
        
        %% capturando todos os fragmentos, portadoras e portências dentro da janela
        pack_tx_segments_window = pack_tx_segments(keys,:);
        pack_tx_segments_window(pack_tx_segments_window <= t_window_start) = 0;
        pack_tx_segments_window(pack_tx_segments_window >= (t_window_start+t_window)) = 0;

        pattern_window = (pack_tx_segments_window ~= 0) .* pattern(keys,:);
        pr_devices = (pack_tx_segments_window ~= 0) .* pr(keys,:);
        pr_I = zeros(size(pr_devices));

        % matrix auxiliar que armazena as colisões
        target_collided_device = [];
        target_collided_interference = [];

        %% identificando headers na trasmissão
        [hr, hc] = find(pack_tx_segments_window(:, 1:3) ~= 0);
        header_tx_window = unique(hr);

        %% inicio da análise por pacotes tendo headers como fonte de pesquisa
        for i=1 : length(header_tx_window)
            
            node_tx = pack_tx_segments_window(header_tx_window(i),:);

            % criando cópia das tx dentro da janela para eliminar o
            % dispositivo transmitido e iniciar a localização das
            % transmissões simultâneas
            pack_tx = pack_tx_segments_window;
            pack_tx(header_tx_window(i),:) = -10;
            pack_tx(pack_tx==0) = -10;

            % início de análise para colisões
            for seg=1:1:length(node_tx)

                % colisões durante transmissão header
                if(seg ~= length(node_tx) && seg <= Header_size)
                    [header_sim_row, header_sim_col] = find(pack_tx(:,1:Header_size) >= (node_tx(seg)-Header_duration) ...
                            & pack_tx(:,1:Header_size) <= (node_tx(seg)+Header_duration));

                    [frag_sim_row, frag_sim_col] = find(pack_tx(:,(Header_size+1):end-1) >= (node_tx(seg)-F_duration) ...
                            & pack_tx(:,(Header_size+1):end-1) <= (node_tx(seg)+Header_duration));

                    [last_sim_row, last_sim_col] = find(pack_tx(:,end) >= (node_tx(seg)-Last_fragment_duration) & ...
                            pack_tx(:,end) <= (node_tx(seg)+Header_duration));
                    
                % colisões durante transmissão fragmento
                elseif(seg~=length(node_tx) && seg > Header_size)
                    [header_sim_row, header_sim_col] = find(pack_tx(:,1:Header_size) >= (node_tx(seg)-Header_duration) ...
                            & pack_tx(:,1:Header_size) <= (node_tx(seg)+F_duration));
                        
                    [frag_sim_row, frag_sim_col] = find(pack_tx(:,(Header_size+1):end-1) >= (node_tx(seg)-F_duration) ...
                            & pack_tx(:,(Header_size+1):end-1) <= (node_tx(seg)+F_duration));

                    [last_sim_row, last_sim_col] = find(pack_tx(:,end) >= (node_tx(seg)-Last_fragment_duration) ...
                            & pack_tx(:,end) <= (node_tx(seg)+F_duration));

                % colisões durante o último fragmento
                else
                    [header_sim_row, header_sim_col] = find(pack_tx(:,1:Header_size) >= (node_tx(seg)-Header_duration) ...
                            & pack_tx(:,1:Header_size) <= (node_tx(seg)+Last_fragment_duration));
                        
                    [frag_sim_row, frag_sim_col] = find(pack_tx(:,(Header_size+1):end-1)>=(node_tx(seg)-F_duration) ...
                            & pack_tx(:,(Header_size+1):end-1)<=(node_tx(seg)+Last_fragment_duration));
                        
                    [last_sim_row, last_sim_col] = find(pack_tx(:,end) >= node_tx(seg) ...
                            & pack_tx(:,end)<=(node_tx(seg)+Last_fragment_duration));
                
                end

                transmission_sim = [header_sim_row, header_sim_col; 
                         frag_sim_row, frag_sim_col + Header_size; %soma para ajuste do index devido a função find eliminar header
                         last_sim_row, last_sim_col + size(pack_tx_segments_window,2)-1]; %soma para ajuste do index

                % verificando colisão entre portadoras
                for c=1:1:size(transmission_sim(:,1))

                    % verifica se houve colisão
                    if pattern_window(transmission_sim(c,1), transmission_sim(c,2)) == pattern_window(header_tx_window(i), seg)
                        pr_I(header_tx_window(i), seg) = pr_I(header_tx_window(i), seg) + pr_devices(transmission_sim(c,1), transmission_sim(c,2));
                        target_collided_device = [target_collided_device; header_tx_window(i), seg];
                        target_collided_interference = [target_collided_interference; transmission_sim(c,1), transmission_sim(c,2)];
                    end

                end

            end

        end

        %% análise de pacotes recebidos
        number_of_colision = nnz(pr_I);         % armazenando o número de colisões
        pack_collided_decoded = (pr_I ~= 0);    % armazenamento da posição onde houve a colisão
        pr_devices_collided = pr_devices .* pack_collided_decoded;

        % relação Sinal interferência
        sir_pack_received = pr_devices_collided./abs(pr_I-pr_devices_collided);
        sir_pack_received = fillmissing(sir_pack_received, 'constant', 0);

        % identificando pacotes recebidos 
        % 1 recebidos com sucesso 
        % 0 caso contrário
        received_pack = (sir_pack_received>4 | sir_pack_received==0) .* (pack_tx_segments_window ~= 0); % multiplicando pela janela
        
        % selecionando pacotes recebidos com sucesso
        pack_success = find(sum(received_pack(:,1:3),2) > 0 & sum(received_pack(:,4:end),2) >= 4);

        

        % removendo recebidos da análise
%         pack_tx_segments(keys(received_successed),:) = 0;

        % incrementando delta para formação de nova janela
        t_window_start = t_window_start + delta_window;
    end
    
    x = [sum(pack_tx_segments(:,1) ~= 0), sum(pack_tx_segments(:,1) == 0)];
end
